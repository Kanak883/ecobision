<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoScan - Waste Detection</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f9eb;
            color: #2c3e50;
        }
        .camera-container {
            position: relative;
            max-width: 640px;
            margin: 0 auto;
        }
        #webcam, #overlay {
            width: 100%;
            border-radius: 10px;
        }
        button {
            background: #27ae60;
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            margin: 15px auto;
        }
    </style>
</head>
<body>
    <div class="camera-container">
        <h1>ðŸŒ± EcoScan</h1>
        <video id="webcam" autoplay muted playsinline></video>
        <canvas id="overlay"></canvas>
        <button id="scanButton">Start Scanning</button>
    </div>

    <script>
        let net;
        let isScanning = false;
        const MIN_CONFIDENCE = 0.7;
        
        // Enhanced class corrections
        const classCorrections = {
            'umbrella': 'paper',
            'cell phone': 'e-waste',
            'cup': obj => obj.score > 0.8 ? 'plastic cup' : 'paper cup',
            'book': 'paper',
            'handbag': 'textile',
            'bottle': 'plastic bottle'
        };

        // Improved material mapping
        const materialMap = {
            'paper': {type: 'paper', color: '#2ed573'},
            'plastic bottle': {type: 'plastic', color: '#ff4757'},
            'can': {type: 'metal', color: '#3498db'},
            'e-waste': {type: 'metal', color: '#3498db'},
            'default': {type: 'unknown', color: '#95a5a6'}
        };

        async function setupWebcam() {
            const video = document.getElementById('webcam');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: {ideal: 640},
                        height: {ideal: 480}
                    }
                });
                video.srcObject = stream;
                return new Promise(resolve => video.onloadedmetadata = resolve);
            } catch (err) {
                alert("Camera access required for waste scanning");
                return null;
            }
        }

        function getMaterial(className) {
            // First check direct matches
            if (materialMap[className]) return materialMap[className];
            
            // Then check partial matches
            const matches = Object.entries(materialMap).find(([key]) => 
                className.toLowerCase().includes(key)
            );
            
            return matches ? matches[1] : materialMap.default;
        }

        async function detectObjects() {
            const video = document.getElementById('webcam');
            const canvas = document.getElementById('overlay');
            const ctx = canvas.getContext('2d');
            
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            const objects = await net.detect(video);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            objects.forEach(obj => {
                if (obj.score < MIN_CONFIDENCE) return;
                
                // Apply class corrections
                let className = classCorrections[obj.class] || obj.class;
                if (typeof className === 'function') className = className(obj);
                
                // Get material data
                const material = getMaterial(className);
                
                // Draw detection
                ctx.strokeStyle = material.color;
                ctx.lineWidth = 3;
                ctx.strokeRect(...obj.bbox);
                
                // Draw label
                ctx.fillStyle = material.color;
                const label = `${className} (${Math.round(obj.score * 100)}%)`;
                ctx.fillRect(obj.bbox[0], obj.bbox[1] - 20, ctx.measureText(label).width + 10, 20);
                ctx.fillStyle = 'white';
                ctx.fillText(label, obj.bbox[0] + 5, obj.bbox[1] - 5);
            });

            if (isScanning) requestAnimationFrame(detectObjects);
        }

        document.getElementById('scanButton').addEventListener('click', async () => {
            if (!isScanning) {
                const video = await setupWebcam();
                if (video) {
                    net = net || await cocoSsd.load();
                    isScanning = true;
                    detectObjects();
                    document.getElementById('scanButton').textContent = 'Stop Scanning';
                }
            } else {
                isScanning = false;
                video.srcObject.getTracks().forEach(track => track.stop());
                document.getElementById('scanButton').textContent = 'Start Scanning';
            }
        });
    </script>
</body>
</html>
